"""
Program #1: Maze Generator
A maze program that allows choosing one of 3 directions (left, middle, right)
Each choice point has three, two, one, or no turns available
Generated by a hardcoded key and callable by maze solver programs
"""

import random
from typing import List, Dict, Tuple, Optional

class MazeGenerator:
    def __init__(self, seed_key: str = "MAZE_2025_CHALLENGE"):
        """
        Initialize maze generator with a hardcoded seed key
        """
        self.seed_key = seed_key
        random.seed(hash(seed_key) % (2**32))  # Ensure consistent maze generation
        self.maze_structure = self._generate_maze_structure()
        self.current_position = 0
        self.decision_count = 0
        self.path_taken = []
        
    def _generate_maze_structure(self) -> List[Dict]:
        """
        Generate the maze structure based on the seed key
        Each position has available directions and outcomes
        Ensures there are always viable paths to success
        """
        maze = []
        
        # First, create a guaranteed success path (backbone)
        backbone_path = self._create_backbone_path()
        
        # Create a deterministic maze based on seed
        for i in range(35):  # 15 decision points
            # Determine available directions (1-3 options)
            num_directions = (hash(f"{self.seed_key}_{i}_dirs") % 3) + 1
            available_directions = ['left', 'middle', 'right'][:num_directions]
            
            # Create outcomes for each direction
            outcomes = {}
            backbone_direction = backbone_path.get(i)
            
            for direction in available_directions:
                outcome_hash = hash(f"{self.seed_key}_{i}_{direction}")
                
                # If this is the backbone direction, ensure it continues the successful path
                if direction == backbone_direction:
                    if i == len(backbone_path) - 1:  # Last node in backbone
                        outcomes[direction] = {'type': 'success', 'score': 100}
                    else:
                        outcomes[direction] = {'type': 'next', 'next_position': i + 1}
                
                # For other directions, create varied outcomes
                else:
                    if i >= 12:  # Later positions more likely to be terminal
                        if outcome_hash % 4 == 0:  # 25% success
                            outcomes[direction] = {'type': 'success', 'score': 85}
                        elif outcome_hash % 4 == 1:  # 25% failure
                            outcomes[direction] = {'type': 'failure', 'score': 0}
                        elif outcome_hash % 4 == 2:  # 25% continue
                            next_pos = min(i + 1, 14)
                            outcomes[direction] = {'type': 'next', 'next_position': next_pos}
                        else:  # 25% jump ahead
                            jump_pos = min(i + 2, 14)
                            outcomes[direction] = {'type': 'next', 'next_position': jump_pos}
                    
                    elif i >= 8:  # Middle positions
                        if outcome_hash % 6 == 0:  # ~17% success
                            outcomes[direction] = {'type': 'success', 'score': 75}
                        elif outcome_hash % 6 == 1:  # ~17% failure
                            outcomes[direction] = {'type': 'failure', 'score': 0}
                        elif outcome_hash % 6 in [2, 3]:  # ~33% continue
                            outcomes[direction] = {'type': 'next', 'next_position': i + 1}
                        elif outcome_hash % 6 == 4:  # ~17% jump ahead
                            jump_pos = min(i + (outcome_hash % 3) + 1, 14)
                            outcomes[direction] = {'type': 'next', 'next_position': jump_pos}
                        else:  # ~17% jump back (creates loops)
                            if i > 2:
                                back_pos = max(0, i - (outcome_hash % 3) - 1)
                                outcomes[direction] = {'type': 'next', 'next_position': back_pos}
                            else:
                                outcomes[direction] = {'type': 'next', 'next_position': i + 1}
                    
                    else:  # Early positions - mostly continue with some variety
                        if outcome_hash % 8 == 0:  # ~12% failure
                            outcomes[direction] = {'type': 'failure', 'score': 0}
                        elif outcome_hash % 8 == 1:  # ~12% early success (rare but possible)
                            outcomes[direction] = {'type': 'success', 'score': 150}  # Bonus for finding early exit
                        elif outcome_hash % 8 in [2, 3, 4]:  # ~37% continue normally
                            outcomes[direction] = {'type': 'next', 'next_position': i + 1}
                        elif outcome_hash % 8 == 5:  # ~12% jump ahead
                            jump_pos = min(i + (outcome_hash % 4) + 2, 14)
                            outcomes[direction] = {'type': 'next', 'next_position': jump_pos}
                        else:  # ~25% alternative path
                            alt_pos = min(i + (outcome_hash % 2) + 1, 14)
                            outcomes[direction] = {'type': 'next', 'next_position': alt_pos}
            
            maze.append({
                'position': i,
                'available_directions': available_directions,
                'outcomes': outcomes,
                'description': f"Decision point {i+1}: Choose your path"
            })
        
        return maze
    
    def _create_backbone_path(self) -> Dict[int, str]:
        """
        Create a guaranteed path from start to finish
        Returns a mapping of position -> direction for the successful path
        """
        backbone = {}
        directions = ['left', 'middle', 'right']
        
        # Create a path through about 6-10 positions (reasonable length)
        path_length = (hash(f"{self.seed_key}_backbone_length") % 5) + 6  # 6-10 steps
        
        # First, determine available directions for each position
        available_dirs_per_pos = {}
        for i in range(8):  # Match the maze size
            num_directions = (hash(f"{self.seed_key}_{i}_dirs") % 3) + 1
            available_dirs_per_pos[i] = directions[:num_directions]
        
        # Now create backbone ensuring directions are available
        for i in range(min(path_length, 7)):  # Match the maze size (8 positions = 0-7)
            available = available_dirs_per_pos[i]
            # Choose from available directions based on seed
            choice_idx = hash(f"{self.seed_key}_backbone_{i}") % len(available)
            backbone[i] = available[choice_idx]
        
        return backbone
    
    def reset_maze(self):
        """Reset maze to starting position"""
        self.current_position = 0
        self.decision_count = 0
        self.path_taken = []
    
    def get_current_state(self) -> Dict:
        """Get current maze state information"""
        if self.current_position >= len(self.maze_structure):
            return {
                'position': self.current_position,
                'available_directions': [],
                'description': "Beyond maze bounds",
                'is_terminal': True
            }
        
        current_node = self.maze_structure[self.current_position]
        return {
            'position': self.current_position,
            'available_directions': current_node['available_directions'],
            'description': current_node['description'],
            'is_terminal': False
        }
    
    def make_choice(self, direction: str) -> Dict:
        """
        Make a choice at current position
        Returns outcome of the choice
        """
        if self.current_position >= len(self.maze_structure):
            return {'type': 'error', 'message': 'Beyond maze bounds'}
        
        current_node = self.maze_structure[self.current_position]
        
        if direction not in current_node['available_directions']:
            return {
                'type': 'error', 
                'message': f"Direction '{direction}' not available. Available: {current_node['available_directions']}"
            }
        
        self.decision_count += 1
        self.path_taken.append(direction)
        
        outcome = current_node['outcomes'][direction]
        
        if outcome['type'] == 'next':
            self.current_position = outcome['next_position']
            return {
                'type': 'continue',
                'message': f"Moved {direction} to position {self.current_position}",
                'new_position': self.current_position
            }
        elif outcome['type'] == 'success':
            return {
                'type': 'success',
                'message': f"Congratulations! You found the exit by going {direction}!",
                'score': outcome['score'] + self.decision_count * 5,  # Bonus for efficiency
                'decisions_made': self.decision_count,
                'path': self.path_taken.copy()
            }
        elif outcome['type'] == 'failure':
            return {
                'type': 'failure',
                'message': f"Dead end! Going {direction} led to a trap.",
                'score': self.decision_count,  # Some points for trying
                'decisions_made': self.decision_count,
                'path': self.path_taken.copy()
            }
    
    def get_maze_info(self) -> Dict:
        """Get complete maze information for analysis"""
        return {
            'total_positions': len(self.maze_structure),
            'maze_structure': self.maze_structure,
            'seed_key': self.seed_key
        }
    
    def simulate_path(self, path: List[str]) -> Dict:
        """
        Simulate a complete path through the maze without changing current state
        Used by maze solver programs
        """
        temp_position = 0
        temp_decisions = 0
        
        for direction in path:
            if temp_position >= len(self.maze_structure):
                return {
                    'type': 'failure',
                    'message': 'Path extends beyond maze',
                    'score': temp_decisions,
                    'decisions_made': temp_decisions,
                    'path': path
                }
            
            current_node = self.maze_structure[temp_position]
            
            if direction not in current_node['available_directions']:
                return {
                    'type': 'failure',
                    'message': f"Invalid direction '{direction}' at position {temp_position}",
                    'score': temp_decisions,
                    'decisions_made': temp_decisions,
                    'path': path
                }
            
            temp_decisions += 1
            outcome = current_node['outcomes'][direction]
            
            if outcome['type'] == 'next':
                temp_position = outcome['next_position']
            elif outcome['type'] == 'success':
                return {
                    'type': 'success',
                    'message': 'Path leads to success!',
                    'score': outcome['score'] + temp_decisions * 5,
                    'decisions_made': temp_decisions,
                    'path': path
                }
            elif outcome['type'] == 'failure':
                return {
                    'type': 'failure',
                    'message': 'Path leads to dead end',
                    'score': temp_decisions,
                    'decisions_made': temp_decisions,
                    'path': path
                }
        
        # Path ended without reaching terminal state
        return {
            'type': 'failure',
            'message': 'Path incomplete',
            'score': temp_decisions,
            'decisions_made': temp_decisions,
            'path': path
        }

# Demo function for testing
def demo_maze():
    """Demonstrate the maze functionality"""
    maze = MazeGenerator()
    
    print("=== MAZE GENERATOR DEMO ===")
    print(f"Maze generated with key: {maze.seed_key}")
    print(f"Total positions in maze: {len(maze.maze_structure)}")
    print()
    
    # Show backbone path (guaranteed success path)
    backbone = maze._create_backbone_path()
    backbone_directions = [backbone.get(i, 'N/A') for i in range(len(backbone))]
    print("🎯 GUARANTEED SUCCESS PATH:")
    print(f"Backbone directions: {' → '.join(backbone_directions)}")
    print(f"Backbone length: {len(backbone)} steps")
    print()
    
    # Show first few positions with more detail
    print("📍 FIRST 5 POSITIONS:")
    for i in range(min(5, len(maze.maze_structure))):
        node = maze.maze_structure[i]
        print(f"\nPosition {i}: {node['description']}")
        print(f"Available directions: {node['available_directions']}")
        
        # Show outcomes for each direction
        for direction, outcome in node['outcomes'].items():
            if outcome['type'] == 'next':
                status = f"→ Position {outcome['next_position']}"
            elif outcome['type'] == 'success':
                status = f"✅ SUCCESS (Score: {outcome['score']})"
            else:
                status = f"❌ Dead end (Score: {outcome['score']})"
            
            is_backbone = direction == backbone.get(i)
            marker = " ⭐" if is_backbone else ""
            print(f"  {direction.upper()}: {status}{marker}")
    
    print("\n⭐ = Part of guaranteed success path")
    
    # Test the backbone path
    print(f"\n🧪 TESTING BACKBONE PATH:")
    backbone_test = [backbone[i] for i in range(len(backbone)) if i in backbone]
    if backbone_test:
        result = maze.simulate_path(backbone_test)
        print(f"Backbone path result: {result['type']} - {result['message']}")
        if result['type'] == 'success':
            print(f"✅ Backbone path works! Score: {result['score']}")
    
    # Test some other paths
    print(f"\n🧪 TESTING OTHER PATHS:")
    test_paths = [
        ['left', 'left', 'left'],
        ['right', 'right', 'right'],
        ['middle', 'middle', 'middle'],
        ['left', 'right', 'middle', 'left']
    ]
    
    for test_path in test_paths:
        result = maze.simulate_path(test_path)
        status = "✅" if result['type'] == 'success' else "❌" if result['type'] == 'failure' else "🔄"
        print(f"Path {test_path}: {status} {result['type']} (Score: {result.get('score', 0)})")

if __name__ == "__main__":
    demo_maze()